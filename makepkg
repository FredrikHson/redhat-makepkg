#!/bin/bash


pkgdir=$(readlink -f -m ./pkg)
srcdir=$(readlink -f -m ./src)
outdir=$(readlink -f -m .)


function printhelp
{
    echo "valid options"
    echo "-a = no archive (package())"
    echo "-b = no build()"
    echo "-c = Clean up work after build"
    echo "-C = Remove $srcdir before building"
    echo "-D = download location"
    echo "-d = no download use existing source files"
    echo "-e = no extract"
    echo "-O = rpm output location"
    echo "-p = no prepare()"
    echo "-P = alternative PKGBUILD file"
    echo "-S = install makedepends with yum before building"
    echo "-U = cleanup makedepends with yum after building"
    echo "-v = no source verification (md5/sha)"
    echo "-r = just print the rpm output name"
    echo "-m = just print the makedepends list"
    echo "-n = output package name prefix"
    echo "-w = fpm workdir sets where fpm puts its temporary files /tmp as default"
}
download_location=$(pwd)
pkgbuildfile="$(pwd)/PKGBUILD"

while getopts "hcCUSapbdevD:O:P:rmn:w:" c;do
    case "$c" in
        h)
            printhelp
            exit 0
            ;;

        c)
            cleanupafter=1
            ;;

        C)
            rm -rf $srcdir
            ;;

        S)
            installbefore=1
            ;;
        U)
            installcleanup=1
            ;;

        a)
            noarchive=1
            ;;

        p)
            noprepare=1
            ;;

        b)
            nobuild=1
            ;;
        d)
            nodownload=1
            ;;
        e)
            noextract=1
            ;;

        v)
            noverify=1
            ;;
        r)
            printrpmname=1
            ;;
        m)
            printmakedeps=1
            ;;
        n)
            nameprefix=$OPTARG
            ;;
        D)
            download_location=$(readlink -f -m $OPTARG)
            ;;

        O)
            outdir=$(readlink -f -m $OPTARG)
            ;;
        w)
            workdir=$(readlink -f -m $OPTARG)
            ;;
        P)
            pkgbuildfile=$(readlink -f -m $OPTARG)
            ;;

        \?)
            echo "invalid option $c"
            ;;
        :)
            echo "Option -$OPTARG requires an argument." >&2
            exit 1
            ;;
    esac
done

if [[ ! -e $pkgbuildfile ]]; then
    echo no PKGBUILD found.
    exit 1
fi

function extract ()
{
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)
                tar xjf $1
                ;;
            *.tar.gz)
                tar xzf $1
                ;;
            *.tar.xz)
                tar xf $1
                ;;
            *.tar.lz)
                tar xf $1
                ;;
            *.bz2)
                tar jxvf $1
                ;;
            *.rar)
                unrar x $1
                ;;
            *.gz)
                gunzip $1
                ;;
            *.tar)
                tar xf $1
                ;;
            *.tbz2)
                tar xjf $1
                ;;
            *.tgz)
                tar xzf $1
                ;;
            *.zip)
                unzip $1
                ;;
            *.jar)
                unzip $1
                ;;
            *.7z)
                7z x $1
                ;;
            *.tar.xz)
                xz -d $1
                ;;
            *)
                ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

function clean()
{
    rm -f *.rpm
    rm -rf pkg
}

function getSourcePath()
{
    echo $1 | perl -pe 's/.*:://g' | perl -pe 's/.*?\+//g' | perl -pe 's/\#.*$//g'
}


function getSourceName()
{
    if [[ $(echo $1 | grep ::) ]]; then
        echo $1 | perl -pe 's/::.*//g'
    else
        basename $1 | perl -pe 's/\#.*$//g' | perl -pe 's/\.git$//'
    fi
}

function getSourceFragment()
{
    echo $1 | grep '#' | perl -pe 's/.*:://g' | perl -pe 's/.*?\+//g' | perl -pe 's/.*\#//g'
}

function getSourceVCS() # none,http,git,svn
{
    if [[ $(echo $1 | grep 'git+https*://') ]]; then
        echo git
        return
    fi
    if [[ $(echo $1 | grep 'git://') ]]; then
        echo git
        return
    fi
    if [[ $(echo $1 | grep 'svn+https*://') ]]; then
        echo svn
        return
    fi
    if [[ $(echo $1 | grep 'https*://') ]]; then
        echo http
        return
    fi
    if [[ $(echo $1 | grep 'ftps*://') ]]; then
        echo http
        return
    fi

    echo none
}

function downloadsources()
{
    if [[ -n "$download_location" ]]; then
        mkdir -p $download_location
        cd $download_location
    fi

    mkdir -p $srcdir

    for src in "${source[@]}"; do
        src_name=$(getSourceName "$src")
        src_path=$(getSourcePath "$src")
        src_fragment=$(getSourceFragment "$src")
        vcs=$(getSourceVCS "$src")

        if [[ "$vcs" == "http" ]]; then
            if [[ ! -e "$src_name" ]]; then
                wget -nc $src_path -O $src_name
            fi
            pushd $srcdir
            ln -sf "$download_location/$src_name" $src_name
            popd
        fi
        if [[ "$vcs" == "git" ]]; then
            if [[ ! -e "$src_name" ]]; then
                git clone --bare $src_path $src_name
            else
                git --git-dir=$src_name fetch origin +refs/tags/*:refs/tags/* --prune
                git --git-dir=$src_name fetch origin +refs/heads/*:refs/heads/* --prune
            fi
            pushd $srcdir
            rm -rf $src_name
            git clone "$download_location/$src_name" $src_name
            if [[ -n "${src_fragment}" ]]; then
                pushd $src_name
                git checkout $(echo ${src_fragment} | perl -pe "s/.*=//")
                popd
            fi
            popd
        fi
        if [[ "$vcs" == "svn" ]]; then
            if [[ ! -e "$src_name" ]]; then
                svn checkout $src_path $src_name
            fi
            pushd $srcdir
            cp -r "$download_location/$src_name" $src_name
            popd
        fi
        if [[ "$vcs" == "none" ]]; then
            pushd $srcdir
            cp "$(dirname $pkgbuildfile)/$src_name" $src_name
            popd
        fi
    done
}

function extractsources()
{
    mkdir -p $srcdir
    cd $srcdir

    for src in "${source[@]}"; do
        src_name=$(getSourceName "$src")
        vcs=$(getSourceVCS "$src")
        if [[ "$vcs" != "git" && "$vcs" != "svn" ]]; then
            extract $src_name
        fi
    done
}

function verifygit()
{
    local src_name=$1
    local sha=$2
    local actualsha=$(git --git-dir=$src_name/.git rev-parse HEAD)
    if [[ "$actualsha" != "$sha" ]]; then
        echo $src_name tag/branch did not match $sha >&2
        exit 1
    fi
}

function verifysources()
{
    cd $srcdir
    numberofsources=${#source[@]}
    for (( i = 0; i < $numberofsources; i++ )); do
        src_name=$(getSourceName "${source[i]}")
        vcs=$(getSourceVCS "${source[i]}")
        if [[ -n "$md5sums" ]]; then
            if [[ "${md5sums[i]}" == "SKIP" ]]; then
                continue
            fi
            if [[ "$vcs" == "git" ]]; then
                verifygit $src_name ${md5sums[i]}
            else
                md5sum -c <(echo "${md5sums[i]}  $src_name") &>/dev/null
                if [[ $? -ne 0 ]]; then
                    echo $src_name failed md5 check >&2
                    exit 1
                fi
            fi
        fi
        if [[ -n "$sha256sums" ]]; then
            if [[ "${sha256sums[i]}" == "SKIP" ]]; then
                continue
            fi
            if [[ "$vcs" == "git" ]]; then
                verifygit $src_name ${sha256sums[i]}
            else
                sha256sum -c <(echo "${sha256sums[i]}  $src_name") &>/dev/null
                if [[ $? -ne 0 ]]; then
                    echo $src_name failed sha256 check >&2
                    exit 1
                fi
            fi
        fi
        if [[ -n "$sha1sums" ]]; then
            if [[ "${sha1sums[i]}" == "SKIP" ]]; then
                continue
            fi
            if [[ "$vcs" == "git" ]]; then
                verifygit $src_name ${sha1sums[i]}
            else
                sha1sum -c <(echo "${sha1sums[i]}  $src_name") &>/dev/null
                if [[ $? -ne 0 ]]; then
                    echo $src_name failed sha1 check >&2
                    exit 1
                fi
            fi
        fi
        if [[ -n "$sha224sums" ]]; then
            if [[ "${sha224sums[i]}" == "SKIP" ]]; then
                continue
            fi
            if [[ "$vcs" == "git" ]]; then
                verifygit $src_name ${sha224sums[i]}
            else
                sha224sum -c <(echo "${sha224sums[i]}  $src_name") &>/dev/null
                if [[ $? -ne 0 ]]; then
                    echo $src_name failed sha224 check >&2
                    exit 1
                fi
            fi
        fi
        if [[ -n "$sha384sums" ]]; then
            if [[ "${sha384sums[i]}" == "SKIP" ]]; then
                continue
            fi
            if [[ "$vcs" == "git" ]]; then
                verifygit $src_name ${sha384sums[i]}
            else
                sha384sum -c <(echo "${sha384sums[i]}  $src_name") &>/dev/null
                if [[ $? -ne 0 ]]; then
                    echo $src_name failed sha384 check >&2
                    exit 1
                fi
            fi
        fi
        if [[ -n "$sha512sums" ]]; then
            if [[ "${sha512sums[i]}" == "SKIP" ]]; then
                continue
            fi
            if [[ "$vcs" == "git" ]]; then
                verifygit $src_name ${sha512sums[i]}
            else
                sha512sum -c <(echo "${sha512sums[i]}  $src_name") &>/dev/null
                if [[ $? -ne 0 ]]; then
                    echo $src_name failed sha512 check >&2
                    exit 1
                fi
            fi
        fi
    done
}

yum_cleanuplist=""

function yum_makedepends()
{
    installedlist=$(rpm -qa --queryformat "%{NAME}\n")
    for dep in ${makedepends[@]}; do
        exists=$(echo "$installedlist" | grep "^$dep$")
        if [[ -z "$exists" ]]; then
            echo $dep needs to be installed
            yum_cleanuplist=$(echo $yum_cleanuplist $dep)
        fi
    done
    if [[ -n "$yum_cleanuplist" ]]; then
        sudo yum install -y $yum_cleanuplist
    fi
}

function yum_cleanup()
{
    if [[ -n "$yum_cleanuplist" ]]; then
        sudo yum remove -y $yum_cleanuplist
    fi
}

function createrpm()
{
    local name=${1}
    ruby_version=$(ruby --version | perl -pe 's/ruby\s([0-9]).*/\1/g')
    if [[ "$ruby_version" -lt "2" ]]; then
        echo needs newer ruby
        if [[ -e "$HOME/.rvm/scripts/rvm" ]]; then
            echo using rvm to get ruby 2.3
            #setup ruby for fpm
            . $HOME/.rvm/scripts/rvm
            rvm 2.3
        else
            echo could not get a new enough ruby version to run fpm on update ruby or install rvm.
            exit 1
        fi
    fi
    cd ${pkgdir}
    echo ${depends[@]}
    fpmflags=""
    for dep in ${depends[@]}; do
        fpmflags=$(echo "$fpmflags --depends $dep")
    done

    for conflict in ${conflicts[@]}; do
        fpmflags=$(echo "$fpmflags --conflicts $conflict")
    done

    for replace in ${replaces[@]}; do
        fpmflags=$(echo "$fpmflags --replaces $replace")
    done

    for provide in ${provides[@]}; do
        fpmflags=$(echo "$fpmflags --provides $provide")
    done

    if [[ -n "$license" ]]; then
        fpmflags=$(echo "$fpmflags --license $license")
    fi
    if [[ -n "$url" ]]; then
        fpmflags=$(echo "$fpmflags --url $url")
    fi
    if [[ -n "$description" ]]; then
        fpmflags=$(echo "$fpmflags --description $pkgdesc")
    fi
    if [[ -n "$workdir" ]]; then
        fpmflags=$(echo "$fpmflags --workdir $workdir")
    fi
    fpm -s dir -t rpm -n ${nameprefix}$name -v "${pkgver}" \
        --iteration $pkgrel \
        --provides ${nameprefix}$name \
        $fpmflags \
        *
    if [[ ! -d "${outdir}" ]]; then
        mkdir -p ${outdir}
    fi
    mv -v *.rpm ${outdir}/
}
function concat_sources()
{
    #handle different sources for x86_64 and i686
    if [[ "${CARCH}" == "x86_64" ]]; then
        if [[ -n ${source_x86_64} ]]; then
            source=("${source[@]}" "${source_x86_64[@]}")
            if [[ -n "$md5sums" ]]; then
                md5sums=("${md5sums[@]}" "${md5sums_x86_64[@]}")
            fi
            if [[ -n "$sha256sums" ]]; then
                sha256sums=("${sha256sums[@]}" "${sha256sums_x86_64[@]}")
            fi
            if [[ -n "$sha1sums" ]]; then
                sha1sums=("${sha1sums[@]}" "${sha1sums_x86_64[@]}")
            fi
            if [[ -n "$sha224sums" ]]; then
                sha224sums=("${sha224sums[@]}" "${sha224sums_x86_64[@]}")
            fi
            if [[ -n "$sha384sums" ]]; then
                sha384sums=("${sha384sums[@]}" "${sha384sums_x86_64[@]}")
            fi
            if [[ -n "$sha512sums" ]]; then
                sha512sums=("${sha512sums[@]}" "${sha512sums_x86_64[@]}")
            fi
        fi
    else
        if [[ -n ${source_i686} ]]; then
            source=("${source[@]}" "${source_i686[@]}")
            if [[ -n "$md5sums" ]]; then
                md5sums=("${md5sums[@]}" "${md5sums_i686[@]}")
            fi
            if [[ -n "$sha256sums" ]]; then
                sha256sums=("${sha256sums[@]}" "${sha256sums_i686[@]}")
            fi
            if [[ -n "$sha1sums" ]]; then
                sha1sums=("${sha1sums[@]}" "${sha1sums_i686[@]}")
            fi
            if [[ -n "$sha224sums" ]]; then
                sha224sums=("${sha224sums[@]}" "${sha224sums_i686[@]}")
            fi
            if [[ -n "$sha384sums" ]]; then
                sha384sums=("${sha384sums[@]}" "${sha384sums_i686[@]}")
            fi
            if [[ -n "$sha512sums" ]]; then
                sha512sums=("${sha512sums[@]}" "${sha512sums_i686[@]}")
            fi
        fi
    fi
}
function rpmname()
{
    for name in ${pkgname[@]}; do
        echo ${nameprefix}${name}-${pkgver}-${pkgrel}.${CARCH}.rpm
    done
}
#setup the architecture flag
CARCH=$(arch)

. $pkgbuildfile

concat_sources
if [[ "$(type -t pkgver)" != "function" ]]; then
    if [[ -n "$printrpmname" ]]; then
        rpmname
        exit 0
    fi

fi

if [[ -n "$printmakedeps" ]]; then
    for i in ${makedepends[@]}; do
        echo $i
    done
    exit 0
fi

if [[ -n "$installbefore" ]]; then
    yum_makedepends
fi
set -e
if [[ -z "$nodownload" ]]; then
    if [[ -n "$printrpmname" ]]; then
        downloadsources &> /dev/null
    else
        echo downloading
        downloadsources
    fi
fi
set +e
if [[ -z "$noverify" ]]; then
    if [[ -n "$printrpmname" ]]; then
        verifysources &>/dev/null
    else
        echo verifying sources
        verifysources
    fi
fi
set -e

if [[ -z "$noextract" ]]; then
    if [[ -n "$printrpmname" ]]; then
        extractsources &> /dev/null
    else
        echo extracting
        extractsources
    fi
fi

if [[ "$(type -t pkgver)" == "function" ]]; then
    pkgver=$(pkgver)
fi

if [[ -n "$printrpmname" ]]; then
    rpmname
    exit 0
fi

if [[ -z "$noprepare" ]]; then
    if [[ "$(type -t prepare)" == "function" ]]; then
        cd $srcdir
        prepare
    fi
fi

if [[ -z "$nobuild" ]]; then
    if [[ "$(type -t build)" == "function" ]]; then
        cd $srcdir
        build
    fi
fi

if [[ -z "$noarchive" ]]; then
    if [[ ${#pkgname[@]} -eq 1 ]]; then
        if [[ "$(type -t package)" == "function" ]]; then
            cd $srcdir
            rm -rf $pkgdir
            mkdir -p $pkgdir
            package
            createrpm $pkgname
        else
            echo missing package function.
            exit 1
        fi
    else
        orig_pkgdir=$pkgdir
        for name in ${pkgname[@]}; do
            if [[ "$(type -t package_${name})" == "function" ]]; then
                pkgdir=${orig_pkgdir}/${name}
                rm -rf $pkgdir
                mkdir -p $pkgdir
                package_${name}
                createrpm ${name}
            else
                echo missing package_${name} function.
                exit 1
            fi

        done
    fi
fi
set +e

if [[ -n "$cleanupafter" ]]; then
    rm -rf $srcdir
    rm -rf $pkgdir
fi

if [[ -n "$installcleanup" ]]; then
    yum_cleanup
fi
